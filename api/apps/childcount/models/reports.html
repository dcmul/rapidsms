

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>childcount.models.reports &mdash; ChildCount+ v2.0(g) documentation</title>
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '2.0(g)',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="ChildCount+ v2.0(g) documentation" href="../../../../index.html" />
    <link rel="up" title="childcount.models" href="index.html" />
    <link rel="next" title="childcount.tasks" href="../tasks.html" />
    <link rel="prev" title="childcount.models.Patient" href="patient.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tasks.html" title="childcount.tasks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="patient.html" title="childcount.models.Patient"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../../index.html">ChildCount+ v2.0(g) documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >API/ChildCount+ Module Reference</a> &raquo;</li>
          <li><a href="../../index.html" >apps</a> &raquo;</li>
          <li><a href="../index.html" >childcount</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">childcount.models</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="childcount-models-reports">
<h1>childcount.models.reports<a class="headerlink" href="#childcount-models-reports" title="Permalink to this headline">¶</a></h1>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">See <a class="reference internal" href="../../../../tech/sms.html#tech-sms-forms-to-database"><em>[U] Adding a New Form</em></a> for information
on how these <tt class="xref py py-class docutils literal"><span class="pre">CCReport</span></tt> objects relate to
<a class="reference internal" href="../forms.html#module-childcount.forms.CCForm" title="childcount.forms.CCForm"><tt class="xref py py-class docutils literal"><span class="pre">childcount.forms.CCForm</span></tt></a> and the database.</p>
</div>
<span class="target" id="module-childcount.models.reports"></span><p>ChildCount Reports</p>
<dl class="class">
<dt id="childcount.models.reports.AgeQuerySet">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">AgeQuerySet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AgeQuerySet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AgeQuerySet" title="Permalink to this definition">¶</a></dt>
<dd><p>For filtering on age at time of encounter</p>
<p>This custom SQL allows us easily to filter to find
CCReports that were recorded when the patient was between
START and END days old (inclusive).</p>
<p>The Django way to do this would be to use and <tt class="xref py py-class docutils literal"><span class="pre">django.db.models.F()</span></tt> + 
<tt class="xref py py-class docutils literal"><span class="pre">datetime.timedelta()</span></tt>
in a <tt class="xref py py-meth docutils literal"><span class="pre">filter()</span></tt> call, but that operation isn&#8217;t supported in
Django 1.1.</p>
<p>init our queryset object member variables</p>
<dl class="method">
<dt id="childcount.models.reports.AgeQuerySet.encounter_age">
<tt class="descname">encounter_age</tt><big>(</big><em>min_days</em>, <em>max_days</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AgeQuerySet.encounter_age"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AgeQuerySet.encounter_age" title="Permalink to this definition">¶</a></dt>
<dd><p>Anyone who is between <cite>min_days</cite> and <cite>max_days</cite>
old (inclusive)</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.AgeQuerySet.encounter_muac_eligible">
<tt class="descname">encounter_muac_eligible</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AgeQuerySet.encounter_muac_eligible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AgeQuerySet.encounter_muac_eligible" title="Permalink to this definition">¶</a></dt>
<dd><p>MUAC eligible kids are 6 months - 5 years old</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.AgeQuerySet.encounter_over_five">
<tt class="descname">encounter_over_five</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AgeQuerySet.encounter_over_five"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AgeQuerySet.encounter_over_five" title="Permalink to this definition">¶</a></dt>
<dd><p>We take anyone between five and 200 years old to be
&#8220;over five&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.AgeQuerySet.encounter_under_five">
<tt class="descname">encounter_under_five</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AgeQuerySet.encounter_under_five"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AgeQuerySet.encounter_under_five" title="Permalink to this definition">¶</a></dt>
<dd><p>Anyone under 365*5 days old at time of encounter</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.AgeQuerySet.latest_for_patient">
<tt class="descname">latest_for_patient</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AgeQuerySet.latest_for_patient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AgeQuerySet.latest_for_patient" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#childcount.models.reports.AgeQuerySet.latest_for_patient" title="childcount.models.reports.AgeQuerySet.latest_for_patient"><tt class="xref py py-meth docutils literal"><span class="pre">latest_for_patient()</span></tt></a> filters the <a class="reference internal" href="#childcount.models.reports.CCReport" title="childcount.models.reports.CCReport"><tt class="xref py py-class docutils literal"><span class="pre">CCReport</span></tt></a> QuerySet
and returns only <a class="reference internal" href="#childcount.models.reports.CCReport" title="childcount.models.reports.CCReport"><tt class="xref py py-class docutils literal"><span class="pre">CCReport</span></tt></a> objects that are the latest such
report for each patient.</p>
<p>For example, if you had a QuerySet of <a class="reference internal" href="#childcount.models.reports.HouseholdVisitReport" title="childcount.models.reports.HouseholdVisitReport"><tt class="xref py py-class docutils literal"><span class="pre">HouseholdVisitReport</span></tt></a>
objects, <a class="reference internal" href="#childcount.models.reports.AgeQuerySet.latest_for_patient" title="childcount.models.reports.AgeQuerySet.latest_for_patient"><tt class="xref py py-meth docutils literal"><span class="pre">latest_for_patient()</span></tt></a> would give you the most
recent <a class="reference internal" href="#childcount.models.reports.HouseholdVisitReport" title="childcount.models.reports.HouseholdVisitReport"><tt class="xref py py-class docutils literal"><span class="pre">HouseholdVisitReport</span></tt></a> for each household.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.AntenatalVisitReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">AntenatalVisitReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AntenatalVisitReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AntenatalVisitReport" title="Permalink to this definition">¶</a></dt>
<dd><p>AntenatalVisitReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, expected_on, sms_alert_id)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.AppointmentReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">AppointmentReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AppointmentReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AppointmentReport" title="Permalink to this definition">¶</a></dt>
<dd><p>AppointmentReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, appointment_date, closed_date, status, task_id, sms_alert_id)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.AppointmentReport.get_omrs_dict">
<tt class="descname">get_omrs_dict</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#AppointmentReport.get_omrs_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.AppointmentReport.get_omrs_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>OpenMRS Key/Value dict.</p>
<p>Return key/value dictionary of openmrs values that this report can
populate</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.BCPillReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">BCPillReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#BCPillReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.BCPillReport" title="Permalink to this definition">¶</a></dt>
<dd><p>BCPillReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, pills, women)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.BedNetReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">BedNetReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#BedNetReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.BedNetReport" title="Permalink to this definition">¶</a></dt>
<dd><p>BedNetReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, sleeping_sites, function_nets, earlier_nets, damaged_nets)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.BednetIssuedReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">BednetIssuedReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#BednetIssuedReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.BednetIssuedReport" title="Permalink to this definition">¶</a></dt>
<dd><p>BednetIssuedReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, bednet_received)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.BednetUtilization">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">BednetUtilization</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#BednetUtilization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.BednetUtilization" title="Permalink to this definition">¶</a></dt>
<dd><p>BednetUtilization(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, child_underfive, child_lastnite, hanging_bednet, reason)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.BirthReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">BirthReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#BirthReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.BirthReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Birth Report</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="attribute">
<dt id="childcount.models.reports.BirthReport.CLINIC_DELIVERY_CHOICES">
<tt class="descname">CLINIC_DELIVERY_CHOICES</tt><a class="headerlink" href="#childcount.models.reports.BirthReport.CLINIC_DELIVERY_CHOICES" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not the baby was delivered in a clinic</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.BirthReport.setup_reminders">
<tt class="descname">setup_reminders</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#BirthReport.setup_reminders"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.BirthReport.setup_reminders" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Setup reminders for neonatal visit</dt>
<dd><ul class="first last simple">
<li>immediate</li>
<li>6 days later</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.CCReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">CCReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#CCReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.CCReport" title="Permalink to this definition">¶</a></dt>
<dd><p>The highest level superclass to be 
inhereted by all other report classes</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.CCReport.get_omrs_dict">
<tt class="descname">get_omrs_dict</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#CCReport.get_omrs_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.CCReport.get_omrs_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>OpenMRS Key/Value dict.</p>
<p>Return key/value dictionary of openmrs values that this report can
populate</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.CCReport.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#CCReport.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.CCReport.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero out the report</p>
</dd></dl>

<dl class="method">
<dt id="childcount.models.reports.CCReport.substantively_equal">
<tt class="descname">substantively_equal</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#CCReport.substantively_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.CCReport.substantively_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Two <a class="reference internal" href="#childcount.models.reports.CCReport" title="childcount.models.reports.CCReport"><tt class="xref py py-class docutils literal"><span class="pre">childcount.models.reports.CCReport</span></tt></a> objects are of the same
type and have all fields equal (except for their
<cite>id</cite>)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.CD4ResultReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">CD4ResultReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#CD4ResultReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.CD4ResultReport" title="Permalink to this definition">¶</a></dt>
<dd><p>CD4ResultReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, cd4_count)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.DBSResultReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">DBSResultReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#DBSResultReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.DBSResultReport" title="Permalink to this definition">¶</a></dt>
<dd><p>DBSResultReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, test_result)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.DBSResultReport.get_omrs_dict">
<tt class="descname">get_omrs_dict</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#DBSResultReport.get_omrs_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.DBSResultReport.get_omrs_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>OpenMRS Key/Value dict.</p>
<p>Return key/value dictionary of openmrs values that this report can
populate</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.DangerSignsReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">DangerSignsReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#DangerSignsReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.DangerSignsReport" title="Permalink to this definition">¶</a></dt>
<dd><p>DangerSignsReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.DeathReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">DeathReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#DeathReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.DeathReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Death Report</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.DrinkingWaterReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">DrinkingWaterReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#DrinkingWaterReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.DrinkingWaterReport" title="Permalink to this definition">¶</a></dt>
<dd><p>DrinkingWaterReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, water_source, treatment_method)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.ExtendedBedNetReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">ExtendedBedNetReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#ExtendedBedNetReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.ExtendedBedNetReport" title="Permalink to this definition">¶</a></dt>
<dd><p>ExtendedBedNetReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, sleeping_sites, function_nets, earlier_nets, damaged_nets, bednetreport_ptr_id, people)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.FamilyPlanningReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">FamilyPlanningReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#FamilyPlanningReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.FamilyPlanningReport" title="Permalink to this definition">¶</a></dt>
<dd><p>FamilyPlanningReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, women, women_using)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.FeverReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">FeverReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#FeverReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.FeverReport" title="Permalink to this definition">¶</a></dt>
<dd><p>FeverReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, rdt_result)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.FollowUpReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">FollowUpReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#FollowUpReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.FollowUpReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Follow-Up Report</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.HIVTestReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">HIVTestReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#HIVTestReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.HIVTestReport" title="Permalink to this definition">¶</a></dt>
<dd><p>HIVTestReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, hiv, blood_drawn)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.HIVTestReport.get_omrs_dict">
<tt class="descname">get_omrs_dict</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#HIVTestReport.get_omrs_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.HIVTestReport.get_omrs_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>OpenMRS Key/Value dict.</p>
<p>Return key/value dictionary of openmrs values that this report can
populate</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.HouseholdVisitReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">HouseholdVisitReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#HouseholdVisitReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.HouseholdVisitReport" title="Permalink to this definition">¶</a></dt>
<dd><p>HouseholdVisitReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, available, children)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.MedicineGivenReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">MedicineGivenReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#MedicineGivenReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.MedicineGivenReport" title="Permalink to this definition">¶</a></dt>
<dd><p>MedicineGivenReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.NeonatalReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">NeonatalReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#NeonatalReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.NeonatalReport" title="Permalink to this definition">¶</a></dt>
<dd><p>NeonatalReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, clinic_visits)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.NutritionReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">NutritionReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#NutritionReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.NutritionReport" title="Permalink to this definition">¶</a></dt>
<dd><p>record nutrition related measurements</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.NutritionReport.diagnose">
<tt class="descname">diagnose</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#NutritionReport.diagnose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.NutritionReport.diagnose" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagnosis of the patient</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.PatientStatusReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">PatientStatusReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#PatientStatusReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.PatientStatusReport" title="Permalink to this definition">¶</a></dt>
<dd><p>PatientStatusReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, status, reason)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.PregnancyRegistrationReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">PregnancyRegistrationReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#PregnancyRegistrationReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.PregnancyRegistrationReport" title="Permalink to this definition">¶</a></dt>
<dd><p>PregnancyRegistrationReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, married, pregnancies, number_of_children, husband_id)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.PregnancyRegistrationReport.get_omrs_dict">
<tt class="descname">get_omrs_dict</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#PregnancyRegistrationReport.get_omrs_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.PregnancyRegistrationReport.get_omrs_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>OpenMRS Key/Value dict.</p>
<p>Return key/value dictionary of openmrs values that this report can
populate</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.PregnancyReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">PregnancyReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#PregnancyReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.PregnancyReport" title="Permalink to this definition">¶</a></dt>
<dd><p>PregnancyReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, pregnancy_month, anc_visits, weeks_since_anc)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.ReferralReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">ReferralReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#ReferralReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.ReferralReport" title="Permalink to this definition">¶</a></dt>
<dd><p>ReferralReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, urgency)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.SPregnancy">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">SPregnancy</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#SPregnancy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.SPregnancy" title="Permalink to this definition">¶</a></dt>
<dd><p>SauriPregnancyReport added extra fields specific to Sauri</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.SUnderOne">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">SUnderOne</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#SUnderOne"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.SUnderOne" title="Permalink to this definition">¶</a></dt>
<dd><p>Sauri under one report with the extra field for vaccine</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.SanitationReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">SanitationReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#SanitationReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.SanitationReport" title="Permalink to this definition">¶</a></dt>
<dd><p>SanitationReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, toilet_lat, share_toilet)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.SickMembersReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">SickMembersReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#SickMembersReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.SickMembersReport" title="Permalink to this definition">¶</a></dt>
<dd><p>SickMembersReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, sick, rdts, positive_rdts, on_treatment)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.StillbirthMiscarriageReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">StillbirthMiscarriageReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#StillbirthMiscarriageReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.StillbirthMiscarriageReport" title="Permalink to this definition">¶</a></dt>
<dd><p>Stillbirth/Miscarriage Report</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
<dl class="method">
<dt id="childcount.models.reports.StillbirthMiscarriageReport.setup_reminders">
<tt class="descname">setup_reminders</tt><big>(</big><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#StillbirthMiscarriageReport.setup_reminders"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.StillbirthMiscarriageReport.setup_reminders" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup alert/reminder to CHW one week after the event</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.UnderOneReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">UnderOneReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#UnderOneReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.UnderOneReport" title="Permalink to this definition">¶</a></dt>
<dd><p>UnderOneReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, breast_only, immunized)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

<dl class="class">
<dt id="childcount.models.reports.VerbalAutopsyReport">
<em class="property">class </em><tt class="descclassname">childcount.models.reports.</tt><tt class="descname">VerbalAutopsyReport</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../../../_modules/childcount/models/reports.html#VerbalAutopsyReport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#childcount.models.reports.VerbalAutopsyReport" title="Permalink to this definition">¶</a></dt>
<dd><p>VerbalAutopsyReport(id, polymorphic_ctype_id, encounter_id, ccreport_ptr_id, done)</p>
<p>Replace Django&#8217;s inheritance accessor member functions for our model
(self.__class__) with our own versions.
We monkey patch them until a patch can be added to Django
(which would probably be very small and make all of this obsolete).</p>
<p>If we have inheritance of the form ModelA -&gt; ModelB -&gt;ModelC then
Django creates accessors like this:
- ModelA: modelb
- ModelB: modela_ptr, modelb, modelc
- ModelC: modela_ptr, modelb, modelb_ptr, modelc</p>
<p>These accessors allow Django (and everyone else) to travel up and down
the inheritance tree for the db object at hand.</p>
<p>The original Django accessors use our polymorphic manager.
But they should not. So we replace them with our own accessors that use
our appropriate base_objects manager.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="patient.html"
                        title="previous chapter">childcount.models.Patient</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../tasks.html"
                        title="next chapter">childcount.tasks</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../../_sources/api/apps/childcount/models/reports.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tasks.html" title="childcount.tasks"
             >next</a> |</li>
        <li class="right" >
          <a href="patient.html" title="childcount.models.Patient"
             >previous</a> |</li>
        <li><a href="../../../../index.html">ChildCount+ v2.0(g) documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >API/ChildCount+ Module Reference</a> &raquo;</li>
          <li><a href="../../index.html" >apps</a> &raquo;</li>
          <li><a href="../index.html" >childcount</a> &raquo;</li>
          <li><a href="index.html" >childcount.models</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Earth Institue and Millennium Villages Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>